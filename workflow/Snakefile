from pathlib import Path
from lib.query_filter import validate_column, query_dicoms, post_filter

configfile: 'config.yml'


df = query_dicoms(config['search_specs'],
                  credentials_file=config['credentials_file'])

# Validate both columns
valid_subject = validate_column(df, 'subject')
valid_session = validate_column(df, 'session')

# Optionally, check if all rows are valid overall
all_valid = valid_subject & valid_session
if all_valid.all():
    print("✅ All subject and session ids are valid!")
else:
    print("⚠️ Some rows have invalid entries:")
    print(df[['StudyDescription','PatientID','StudyDate','subject','session']][~all_valid])


df = post_filter(df,config['post_filter_specs'])

#write this out so user can inspect
print('Writing list of filtered studies to cfmm2bids_filtered_studies.tsv')
df.to_csv('cfmm2bids_filtered_studies.tsv',sep='\t',index=False)


localrules: dataset_description


# Build BIDS-style output targets
sub_ses_targets = expand(
    'bids/sub-{subject}/ses-{session}',
    zip,
    subject=df.subject,
    session=df.session
)

# Build QC report targets
qc_report_targets = expand(
    'sourcedata/qc/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_series.svg',
    zip,
    subject=df.subject,
    session=df.session
)


rule all:
    input: 
        sub_ses_targets,
        'bids/dataset_description.json',
        qc_report_targets


def get_uid_from_wildcards(wildcards):
    matches = lookup(
        query=f"subject == '{wildcards.subject}' and session == '{wildcards.session}'",
        within=df
    )
    if isinstance(matches, tuple):
        return matches.StudyInstanceUID
    else:
        ids = [m.StudyInstanceUID for m in matches]
        bad_ids = "\n".join(ids)
        raise LookupError(f'Multiple studies matched with identical subject and session identifiers: \n{bad_ids}')



rule download_tar:
    params:
        uid=get_uid_from_wildcards,
        cfmm2tar_download_options=config['cfmm2tar_download_options'],
        creds_file=config['credentials_file']
    output:
        dicoms_dir=directory('sourcedata/sub-{subject}/ses-{session}')
    log:
        'logs/download_tar/sub-{subject}_ses-{session}.log'
    threads: 1
    resources:
        mem_mb=4000,
        runtime=15
    shell:
        "cfmm2tar -c {params.creds_file} {params.cfmm2tar_download_options} -u {params.uid} {output.dicoms_dir} &> {log}"

rule heudiconv:
    input:
        dicoms_dir='sourcedata/sub-{subject}/ses-{session}',
        heuristic=config['heuristic'],
        dcmconfig_json=config['dcmconfig_json'],
    params: 
        heudiconv_options=config['heudiconv_options'],
        in_auto_txt='bids/.heudiconv/{subject}/ses-{session}/info/{subject}_ses-{session}.auto.txt',
        in_dicominfo_tsv='bids/.heudiconv/{subject}/ses-{session}/info/dicominfo_ses-{session}.tsv',
        in_filegroup_json='bids/.heudiconv/{subject}/ses-{session}/info/filegroup_ses-{session}.json',
        out_info_dir='sourcedata/heudiconv/sub-{subject}/ses-{session}',
    output:
        bids_subj_dir=directory('bids/sub-{subject}/ses-{session}'),
        auto_txt='sourcedata/heudiconv/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_auto.txt',
        dicominfo_tsv='sourcedata/heudiconv/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_dicominfo.tsv',
        filegroup_json='sourcedata/heudiconv/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_filegroup.json'
    log:
        'logs/heudiconv/sub-{subject}_ses-{session}.log'
    shadow: 'minimal'
    threads: 16
    resources: 
        mem_mb=8000,
        runtime=15
    group: 'convert'
    shell:
        (
            "heudiconv --files {input.dicoms_dir}"
            " -c dcm2niix"
            " -o bids"
            " -ss {wildcards.session}"
            " -s {wildcards.subject}"
            " -f {input.heuristic}"
            " --bids notop"
            " --dcmconfig {input.dcmconfig_json}"
            " --overwrite"
            " {params.heudiconv_options} &> {log}"
            " && mkdir -p {params.out_info_dir}"
            " && cp {params.in_auto_txt} {output.auto_txt}"
            " && cp {params.in_dicominfo_tsv} {output.dicominfo_tsv}"
            " && cp {params.in_filegroup_json} {output.filegroup_json}"
        )

rule dataset_description:
    input:
        'resources/dataset_description.json'
    output:
        'bids/dataset_description.json'
    log:
        'logs/dataset_description/dataset_description.log'
    shell:
        'cp {input} {output} &> {log}'


rule generate_qc_report:
    input:
        auto_txt='sourcedata/heudiconv/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_auto.txt',
        dicominfo_tsv='sourcedata/heudiconv/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_dicominfo.tsv',
        filegroup_json='sourcedata/heudiconv/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_filegroup.json'
    output:
        series_list='sourcedata/qc/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_series.svg',
        unmapped='sourcedata/qc/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_unmapped.svg'
    log:
        'logs/generate_qc_report/sub-{subject}_ses-{session}.log'
    threads: 1
    resources: 
        mem_mb=4000,
        runtime=10
    group: 'convert'
    script:
        'scripts/generate_qc_report.py'

